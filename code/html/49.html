<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link rel=stylesheet href="../css/49.css"/>
<script type="text/javascript" src="../scripts/d3.js"></script>
<!--  <script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="../scripts/jquery.min.js"></script>
</head>
<body>

  <div id="rules_names_panel">
  </div>
  <div id="center">
    <div id = "LHS_panel">
    </div>
    <div id = "RHS_panel">
    </div>
    <div class="clear">
    </div>
    <div id = "main_graph_panel">
    </div>
  </div>
  <div id = "selection_panel">
  </div>
  <div class = "clear">
  </div>
  <div id="buttons" align="center">
    <button id="save_data"> Save the graph </button>
    <button id="start_delete_node"> Start deleting </button>
    <button id="stop_delete_node"> Stop deleting </button>
    <button id="add_node_type"> Add Node Type </button>
    <button id="add_rule"> Add Rule </button>
  </div>

  <script type="text/javascript">

/*
- This is same as 48.html except that this is more optimized.
*/


/*************************************** VARIABLES *****************************************/

    var main_graph = new Graph([],[]);  //this is the graph in the graph panel on which grammar rules will be applied
    var current_LHS_graph = new Graph([],[]);	//present graph in LHS panel
    var current_RHS_graph = new Graph([],[]);	//present graph in RHS panel
    var current_NAC_graph = new Graph([],[]);	//present graph in RHS panel
    var rules_names = [];
    var generative_grammar_rules = [];
    var all_graphs_obj = {"main_graph":main_graph, "lhs": current_LHS_graph, "rhs":current_RHS_graph}

    var width = 900;
    var height = 400;
    var color = d3.scale.category20();

    var delete_bool = false;
    var node_types = ["E"];  //to store the node types and display them in selection panel
    var current_node_type = "E";
    var current_node_color = color(1);

    current_LHS_graph.svg_container = d3.select("#LHS_panel").append("svg");
    current_RHS_graph.svg_container = d3.select("#RHS_panel").append("svg");
    main_graph.svg_container = d3.select("#main_graph_panel").append("svg");

/*************************************** MAIN CODE *****************************************/
    d3.json("../json/49.json", function(error, dataset) {
      node_types = dataset.node_types;
      main_graph.nodes = dataset.main_graph.nodes;
      main_graph.links = dataset.main_graph.links;
      try{
        generative_grammar_rules = dataset.generative_grammar_rules;
        for(var i=0; i<generative_grammar_rules.length; i++){
          rules_names.push(generative_grammar_rules[i].name);
        }

	for(var key in all_graphs_obj){		//populating current_LHS_graph and current_RHS_graph
	  if(key == "main_graph") continue;
	  all_graphs_obj[key].nodes = generative_grammar_rules[0][key].nodes || {nodes:[]};
	  all_graphs_obj[key].links = generative_grammar_rules[0][key].links || {links:[]};
	}
      }
      catch(error){
      }

      for(var key in all_graphs_obj){		//setting the force etc. for all the graphs 
        all_graphs_obj[key].node = all_graphs_obj[key].svg_container.selectAll(".node");
        all_graphs_obj[key].link = all_graphs_obj[key].svg_container.selectAll(".link");

	if(key != "main_graph") var new_width = width/2, new_height = height/2;
	else var new_width = width, new_height = height;
	all_graphs_obj[key].force = d3.layout.force()
					.size([new_width,new_height])
					.charge(-60)
					.linkDistance(30);

	all_graphs_obj[key].force.nodes(all_graphs_obj[key].nodes)
			 	 .links(all_graphs_obj[key].links)
				 .start();

/*	all_graphs_obj[key].svg_container.on("click", function(){
						var this_event = this;
						console.log(key);
						all_graphs_obj[key].add_node(this_event);});
						*/

	all_graphs_obj[key].nodes = all_graphs_obj[key].force.nodes();
	all_graphs_obj[key].links = all_graphs_obj[key].force.links();
      }

//I have to call the events on each graph like this separately. It's not working when I try to loop on all_graphs_obj.
      main_graph.force.on("tick", function(){ main_graph.tick();});
      current_LHS_graph.force.on("tick", function(){ current_LHS_graph.tick();});
      current_RHS_graph.force.on("tick", function(){ current_RHS_graph.tick();});

      main_graph.svg_container.on("click", function(){
      					var this_event = this;
					main_graph.add_node(this_event);});
      current_LHS_graph.svg_container.on("click", function(){
      					var this_event = this;
					current_LHS_graph.add_node(this_event);});
      current_RHS_graph.svg_container.on("click", function(){
      					var this_event = this;
					current_RHS_graph.add_node(this_event);});

      for(var key in all_graphs_obj){
	all_graphs_obj[key].restart(); 
      }

//Updating selection panel and rules names panel
      update_selection_panel();
      update_rules_names_panel();
    });

/*************************************** FUNCTIONS ****************************************
* graph constructor
* key
* add_node
* delete_node
* add_link
* tick
* node_click
* update
* enter
* exit
* update_selection_panel
*/

//Graph constructor

  function Graph(nodes, links){  //Graph constructor
    this.nodes = nodes;
    this.links = links;
    this.count = 0;
  }

    Graph.prototype.restart= restart;
    Graph.prototype.update= update;
    Graph.prototype.update_links= update_links;
    Graph.prototype.update_nodes= update_nodes;
    Graph.prototype.update_shapes= update_shapes;
    Graph.prototype.update_labels= update_labels;
    Graph.prototype.update_titles= update_titles;
    Graph.prototype.enter= enter;
    Graph.prototype.enter_links= enter_links;
    Graph.prototype.enter_nodes= enter_nodes;
    Graph.prototype.exit= exit;
    Graph.prototype.exit_links= exit_links;
    Graph.prototype.exit_nodes= exit_nodes;
    Graph.prototype.key= key;
    Graph.prototype.add_node= add_node;
    Graph.prototype.delete_node= delete_node;
    Graph.prototype.add_link= add_link;
    Graph.prototype.tick= tick;
    Graph.prototype.node_click= node_click;

//key function      
    function key(datum) {
      return datum.key;
    }

//add node
//add a node by clicking anywhere on the svg canvas. While adding the key to the node, find the max. key existing till then, and add the next no. as the key to the incoming node.
    function add_node(this_event) {
      d3.event.stopPropagation();
      var point = d3.mouse(this_event);
      var new_key = d3.max(this.nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
      if(!new_key) new_key = 0;
      var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color,group:Math.round(Math.random()*10)};
      this.nodes.push(node_item);
      this.restart();
    }

//delete node
    function delete_node(d,i){
      d3.event.stopPropagation();
      var indices_to_be_deleted = [];
      for(var j=0; j<this.links.length; j++){  //creating the list of indices of links to be deleted
        if((this.links[j].source.index === i) || (this.links[j].target.index === i)){
          indices_to_be_deleted.push(j);
        }
      }
      indices_to_be_deleted.reverse();  //reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

      for(var j=0; j<indices_to_be_deleted.length; j++){
        this.links.splice(indices_to_be_deleted[j],1)  //delete one element i.e. at the index j
      }

      //then delete the node itself
      this.nodes.splice(i,1);  //delete one node i.e. at the index i.
      this.restart();

    }

//add link
//add a link by clicking on the source node and the target node
    function add_link(d,i){
      d3.event.stopPropagation();
      if(this.count == 1)  { //clicked on target 
        this.target = i;
        this.target_key = this.nodes[i].key;  //I had to do this.target_key (not just target_key) because once it leaves this loop, the target_key should still be stored, but I dont want it to be a global variable.
        if (this.source !== this.target){
          var new_key = this.source_key + "-" + this.target_key; //the link key is depending on its source key and target key
	  var link_item = {key:new_key, source:this.source, target:this.target};
	  console.log(link_item);
          this.links.push(link_item);
          this.count = 0;
          this.restart();
      }
    }
        else if (this.count == 0){  //clicked on source
          this.source = i;
          this.source_key = this.nodes[i].key;
          this.count = 1;
        }
    }

//tick
      
    function tick() {
      this.link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      this.node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
    }

//node click
    function node_click(d,i){
      if (delete_bool === true) this.delete_node(d,i);
      else this.add_link(d,i);
      this.restart();
    }

/****** update *********/
    function update(){
      this.update_links();
      this.update_nodes();
    }

//update_links
    function update_links(){
      this.link = this.link.data(this.links, this.key);
    }

//update_nodes
    function update_nodes(){
      this.node = this.node.data(this.nodes, this.key);
      this.update_shapes();
      this.update_labels();
      this.update_titles();
    }

//update_shapes
    function update_shapes(){
      var graph = this;
      var node_shapes = this.svg_container.selectAll("g .node_shape");
      node_shapes
      .attr("r", function(datum){
          if(datum.label === "e") return 5;
          else return 9;
        })
      .attr("fill", function(d){ return d.color})
      .on("click", function(datum, index){
        graph.node_click(datum, index);});
    }

//update_labels
    function update_labels(){
      var node_labels = this.svg_container.selectAll("g .node_label");
      node_labels
      .text(function(datum){return datum.label;});
    }

//update_titles
    function update_titles(){
      var node_titles = this.svg_container.selectAll("g .node_title");
      node_titles
      .text(function(d,i) {return i});
    }
      
/****** enter *********/
    function enter(){
      this.enter_links();
      this.enter_nodes();
    }

//enter_links
    function enter_links(){
      this.link.enter().insert("line",".node")
      .attr("class", "link");
    }

//enter_nodes
    function enter_nodes(){
      var graph = this;
      var gnode = this.node.enter().append("g")
        .attr("class", "node");

      var gnode_circles = gnode.append("circle")
      .attr("class", "node_shape")
      .attr("r", function(datum){
          if(datum.label === "e") return 5;
          else return 9;
        })
      .attr("fill", function(d){ return d.color})
      .on("click", function(datum, index){
        graph.node_click(datum, index);})
      .call(graph.force.drag);

      gnode.append("text")
      .attr("class", "node_label")
      .attr("fill", "white")
      .attr("text-anchor", "middle")
      .attr("font-family", "calibri")
      .attr("font-size", 13)
      .attr("font-weight", "bold")
      .attr("y", 3.5)
      .style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
      .text(function(datum){return datum.label;});

      gnode.append("title")
      .attr("class", "node_title")
      .text(function(d,i) {return i});
    }

/****** exit *********/
    function exit(){
      this.exit_links();
      this.exit_nodes();
    }

//exit_links
    function exit_links(){
      this.link.exit().remove();
    }

//exit_nodes
    function exit_nodes(){
      this.node.exit().remove();
    }
      
/****** restart *********/
    function restart()
    {
      this.update();
      this.enter();
      this.exit();
      this.force.start();
    }

/****** update selection panel *********/
    function update_selection_panel(){
      d3.select("#selection_panel").selectAll("p")
      .data(node_types)
      .enter()
      .append("p")
      .text(function(datum,index){
        return datum;
      })
      .on("click", function(datum,index){
        current_node_type = node_types[index];
        current_node_color = color(index);
      })
      .on("mouseover", function(datum,index){
        d3.select(this).style("background-color",color(index));
      })
      .on("mouseout",function(datum,index){
        d3.select(this).style("background-color","white");
      });
    }

/****** update rules names panel *********/
    function update_rules_names_panel(){
      d3.select("#rules_names_panel").selectAll("p")
      .data(rules_names)
      .enter()
      .append("p")
      .text(function(datum){return datum})
      .on("click", function(datum, index){

        for(var key in all_graphs_obj){
          if(key == "main_graph") continue;
          all_graphs_obj[key].nodes = generative_grammar_rules[index][key].nodes;
          all_graphs_obj[key].links = generative_grammar_rules[index][key].links;
          all_graphs_obj[key].force.nodes(all_graphs_obj[key].nodes)
    			 	 .links(all_graphs_obj[key].links)
  				 .start();
          all_graphs_obj[key].nodes = all_graphs_obj[key].force.nodes();
	  all_graphs_obj[key].links = all_graphs_obj[key].force.links();
	  all_graphs_obj[key].restart(); 
        }

      });
    }

/*************************************** HANDLING THE BUTTONS *****************************************/

    $(document).ready(function(){
      $("#save_data").click(function(){
      main_graph_nodes_copy = [];  //I will copy only some attributes of nodes into this.
      main_graph_links_copy = [];
      for (var i=0; i<main_graph.nodes.length; i++)
      {
        main_graph_nodes_copy[i] = {};
        main_graph_nodes_copy[i].key = main_graph.nodes[i].key;
        main_graph_nodes_copy[i].label = main_graph.nodes[i].label;
        main_graph_nodes_copy[i].name = main_graph.nodes[i].name;
        main_graph_nodes_copy[i].group = main_graph.nodes[i].group;
        main_graph_nodes_copy[i].color = main_graph.nodes[i].color;
      }
      
      for(var i=0; i<main_graph.links.length; i++)
      {

        main_graph_links_copy[i] = {};
        main_graph_links_copy[i].key = main_graph.links[i].key;
        main_graph_links_copy[i].source = main_graph.links[i].source.index;
        main_graph_links_copy[i].target = main_graph.links[i].target.index;
      }
    

      node_types_string = JSON.stringify(node_types);

      main_graph_object = {"nodes":main_graph_nodes_copy,"links":main_graph_links_copy};
      main_graph_string = JSON.stringify(main_graph_object);
      console.log(main_graph_string);
      console.log(node_types_string);

      var generative_grammar_rules_array = []
      for(var i=0; i<generative_grammar_rules.length; i++){
        generative_grammar_rules_array[i] = {};
        generative_grammar_rules_array[i].name = generative_grammar_rules[i].name;
        console.log(generative_grammar_rules[i]);
        console.log(generative_grammar_rules[i]["lhs"].nodes.length);
	
        for(var key in all_graphs_obj){
	  if(key == "main_graph") continue;
          generative_grammar_rules_array[i][key] = {};
          var nodes_copy = [];
          for(var k in generative_grammar_rules[i][key].nodes){
            console.log("entered " + k + " times");
            nodes_copy[k] = {};
            nodes_copy[k].key = generative_grammar_rules[i][key].nodes[k].key;
            nodes_copy[k].label = generative_grammar_rules[i][key].nodes[k].label;
            nodes_copy[k].name = generative_grammar_rules[i][key].nodes[k].name;
            nodes_copy[k].group = generative_grammar_rules[i][key].nodes[k].group;
            nodes_copy[k].color = generative_grammar_rules[i][key].nodes[k].color;
          }
          generative_grammar_rules_array[i][key].nodes = nodes_copy;
          var links_copy = [];
          for(var k in generative_grammar_rules[i][key].links){
            links_copy[k] = {};
            links_copy[k].key = generative_grammar_rules[i][key].links[k].key;
            links_copy[k].source = generative_grammar_rules[i][key].links[k].source.index;
            links_copy[k].target = generative_grammar_rules[i][key].links[k].target.index;
          }
          generative_grammar_rules_array[i][key].links = links_copy;
        }
      }

      generative_grammar_rules_string = JSON.stringify(generative_grammar_rules_array);
        
        $.ajax({
          type: "POST",
          url: "../php/49.php",
          data: {main_graph:main_graph_string, node_types:node_types_string, generative_grammar_rules: generative_grammar_rules_string}
          }).done( function(msg){
            alert( "Data Saved: \n" + msg );
            }).fail( function( xmlHttpRequest, statusText, errorThrown ) {
              alert(
                "Your form submission failed.\n\n"
                + "XML Http Request: " + JSON.stringify( xmlHttpRequest )
                + ",\nStatus Text: " + statusText
                + ",\nError Thrown: " + errorThrown );
              });
      });

//on clicking the button, 'start deleting'
      $("#start_delete_node").click(function(){delete_bool = true;
      console.log(delete_bool);
      d3.select("body").append("text")
      .attr("class","delete_text")
      .text("Click on any node to delete it.");});

//on clicking the button, 'stop deleting'
      $("#stop_delete_node").click(function(){delete_bool = false;
      console.log(delete_bool);
      d3.selectAll(".delete_text").remove();});
      
//on clicking the button, 'add node type'
      d3.select("#add_node_type").on("click",function(){
        var label = prompt("Please specify the name of new type, say, in 1 or 2 letters.","");
        if(label){ 
          node_types.push(label);
          update_selection_panel();
	}
      });

//on clicking the button, 'add rule'
      d3.select("#add_rule").on("click", function(){
        var rule_name = prompt("Please specify a name for the rule.", "");
        rules_names.push(rule_name);
        var lhs = {"nodes":[],"links":[]};
        var rhs = {"nodes":[],"links":[]};
        var nac = {"nodes":[],"links":[]};
        var index = generative_grammar_rules.length;
        generative_grammar_rules.push({"name":rule_name, "lhs":lhs, "rhs":rhs,"nac":nac});

	for(var key in all_graphs_obj){
          if(key == "main_graph") continue;
          all_graphs_obj[key].nodes = generative_grammar_rules[index][key].nodes;
          all_graphs_obj[key].links = generative_grammar_rules[index][key].links;
          all_graphs_obj[key].force.nodes(all_graphs_obj[key].nodes)
    			 	 .links(all_graphs_obj[key].links)
  				 .start();
          all_graphs_obj[key].nodes = all_graphs_obj[key].force.nodes();
	  all_graphs_obj[key].links = all_graphs_obj[key].force.links();
	  all_graphs_obj[key].restart(); 
        }
        update_rules_names_panel();
      });
    });

</script>


