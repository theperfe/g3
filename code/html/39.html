

	<!DOCTYPE html>
	<meta charset="utf-8">
	<head>

	<style>

	.link {
	  stroke: #999;
	}

	</style>


	<script type="text/javascript" src="../scripts/d3.js"></script>
<!--	<script src="http://d3js.org/d3.v3.min.js"></script>-->
	<script src="../scripts/jquery.min.js"></script>

	</head>

	<body>
		<div id="viz"></div>
		<div align="center">
			<button id="save_data"> Save the graph </button>
			<button id="start_delete_node"> Start deleting </button>
			<button id="stop_delete_node"> Stop deleting </button>
		</div>
		<script type="text/javascript">

	//In this I am trying to add text inside the nodes.


			var width = 1270;
			var height = 600;
			var color = d3.scale.category20();

//			var nodes = [{label:"e",group:1},{label:"e",group:2,},];	//just some two nodes to start with
//			var links = [{"source":0, "target":1}];	//just an edge to start with

			var nodes=[], links=[];
			var delete_bool = false;
			var count = 0; //to know whether the mouse click was on the source node or on the target node while creating edges.
			var source, target; //source and target nodes while creating edges using mouse clicks.

			var force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

			var svg = d3.select("#viz")
				.append("svg")
				.attr("width",width)
				.attr("height", height)
				.style("border", "2px solid black")

//loading initial graph from json file. This graph can later be modified through the GUI.
			d3.json("../json/9.json", function(error, graph)
			{

				force.nodes(graph.nodes)
				.links(graph.links)
				.start()
				.on("tick", tick);
	
				svg.on("mousedown", svg_mousedown);

			   var node = svg.selectAll(".node");
			   var link = svg.selectAll(".link");
//			   var text = svg.selectAll("text.label");

			nodes = force.nodes(),
			    links = force.links();

			
			function key(datum)
			{
				return datum.key;
			}


//add a node by clicking anywhere on the svg canvas
			function svg_mousedown()
			{
				d3.event.stopPropagation();
				var point = d3.mouse(this);
				var keys_array = [];
				for (var i=0; i<nodes.length; i++)
				{
					keys_array.splice(i,0,parseInt(nodes[i].key));
				}
				var new_key = d3.max(keys_array) + 1;
//				console.log(new_key);

				var node_item = {key:new_key,x:point[0],y:point[1],label:"U",group:Math.round(Math.random()*10)};
				nodes.push(node_item);
				restart();
			}

//when a source node and target node is clicked, a link is added between them.

			function node_mousedown(d,i) 
			{
				d3.event.stopPropagation();
				console.log("index of clicked node is " + i);
				if(delete_bool === true)
				{
					//first delete all the links connected to this node
					var indices_to_be_deleted = [];
					console.log("index of node to be deleted is " + i);
					for(var j=0; j<links.length; j++){	//creating the list of indices of links to be deleted
//						console.log("source of link " + j + " is " + links[j].source.index);
//						console.log("target of link " + j + " is " + links[j].target.index);
						if((links[j].source.index === i) || (links[j].target.index === i)){
//							console.log("entered");
							indices_to_be_deleted.push(j);
						}
					}
					console.log(indices_to_be_deleted);
					indices_to_be_deleted.reverse();	//reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

					for(var j=0; j<indices_to_be_deleted.length; j++){
						links.splice(indices_to_be_deleted[j],1)	//delete one element i.e. at the index j
					}

					//then delete the node itself
					nodes.splice(i,1);	//delete one nodes i.e. at the index i.
					console.log(nodes);
					restart();
					
				}

				else
				{

					if(count == 1)	//clicked on target
					{
						target = i;
						if (source !== target){
							var keys_array = [];
							for (var j=0; j<links.length; j++)
							{
								keys_array.splice(j,0,parseInt(links[j].key));
							}
							var new_key = d3.max(keys_array) + 1;

//							console.log(new_key);
							links.push({key:new_key, "source":source, "target":target});
							count = 0;
							restart();
						}
					}
					else if (count == 0)	//clicked on source
					{
						source = i;
						count = 1;
					}
				}

			}
				

			function tick() {
				link.attr("x1", function(d) { return d.source.x; })
				    .attr("y1", function(d) { return d.source.y; })
				    .attr("x2", function(d) { return d.target.x; })
				    .attr("y2", function(d) { return d.target.y; });

//				node.attr("cx", function(d) { return d.x; })
//				    .attr("cy", function(d) { return d.y; });

				node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
				
			}

			function restart()
			{

				link = link.data(links);

				link.enter().insert("line",".node")
				.attr("class", "link");

				link.exit().remove();

				node = node.data(nodes);
				console.log(nodes);

				gnode = node.enter().append("g")
					.attr("class", "node");
				
				gnode.append("circle")
				.attr("class", "node")
				.attr("r", function(datum){
						console.log(datum.label);
						if(datum.label === "e") return 5;
						else return 9;
					})
				.attr("fill", function(d){ return color(d.group);})
				.on("mousedown", node_mousedown)
				.call(force.drag);

				gnode.append("text")
				.attr("class", "label")
				.attr("fill", "white")
/*				.attr("fill", function(datum){
						a = d3.hsl(color(datum.group));
						if (a.h === 180) a.h=0;
						else if(a.h > 180) a.h -= 180;
						else if(a.h < 180) a.h += 180;
						a.s = 0.2;
						a.l = 0.5;
						return a;
					})
					*/
				.attr("text-anchor", "middle")
				.attr("font-family", "calibri")
				.attr("font-size", 13)
				.attr("font-weight", "bold")
				.attr("y", 3.5)
				.style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
				.text(function(datum){return datum.label;});

				gnode.append("title")
				.text(function(d,i) {return i});

				node.exit().remove(); //it's important that exit always comes after enter. 

				force.start();

			}


			restart();

			});

			$(document).ready(function(){
				$("#save_data").click(function(){
				nodes_copy = [];	//I will copy only some attributes of nodes into this.
				links_copy = [];
				for (var i=0; i<nodes.length; i++)
				{
					nodes_copy[i] = {};
					nodes_copy[i].key = nodes[i].key;
					nodes_copy[i].label = nodes[i].label;
					nodes_copy[i].name = nodes[i].name;
					nodes_copy[i].group = nodes[i].group;
				}
				
				for(var i=0; i<links.length; i++)
				{

					links_copy[i] = {};
					links_copy[i].key = links[i].key;
					links_copy[i].source = links[i].source.index;
					links_copy[i].target = links[i].target.index;
				}
			

					nodes_string = JSON.stringify(nodes_copy);					
					links_string = JSON.stringify(links_copy);
					console.log(nodes_string);
					console.log(links_string);
					
					$.ajax({
						type: "POST",
						url: "../php/9.php",
						//data: "name=John&location=Boston&count="+count
						data: {nodes:nodes_string, links: links_string}
						}).done( function(msg){
							alert( "Data Saved: \n" + msg );
							}).fail( function( xmlHttpRequest, statusText, errorThrown ) {
								alert(
									"Your form submission failed.\n\n"
									+ "XML Http Request: " + JSON.stringify( xmlHttpRequest )
									+ ",\nStatus Text: " + statusText
									+ ",\nError Thrown: " + errorThrown );
								});
				});

				$("#start_delete_node").click(function(){delete_bool = true;});
				$("#stop_delete_node").click(function(){delete_bool = false;});

			});

	</script>


