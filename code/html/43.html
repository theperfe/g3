	<!DOCTYPE html>
	<meta charset="utf-8">
	<head>
	<style>
	.link {
	  stroke: steelblue;
	  stroke-width: 3;
	}
	.node{
		stroke: white;
		stroke-width: 1.5px;
	}
	.node_label{
		stroke:none;
	}

	#graph_panel{
		float:left;
		min-width:900px;
		min-height: 600px;
	}

	#selection_panel{
		float: right;
		position: relative;
		min-height: 600px;
		min-width: 300px;
		display: block;
	}

	p{
		margin:0em;
	}
	</style>
	<script type="text/javascript" src="../scripts/d3.js"></script>
<!--	<script src="http://d3js.org/d3.v3.min.js"></script>-->
	<script src="../scripts/jquery.min.js"></script>
	</head>
	<body>
		<div id="viz">
		</div>
<!--		<div id="selection_panel"></div>-->
		<div id="buttons" align="center">
			<button id="save_data"> Save the graph </button>
			<button id="start_delete_node"> Start deleting </button>
			<button id="stop_delete_node"> Stop deleting </button>
			<button id="add_node_type"> Add Node Type </button>
		</div>
		<script type="text/javascript">

	//In this I am trying to add the select boxes on the right side of the window so that people can specify the type of the node they want i.e. they will only specify the label to the node. I will choose a color randomly. Later I will add the option, like AGG, if they want to choose circle or rectangle or oval etc.

			var width = 900;
			var height = 600;
			var color = d3.scale.category20();

//			var nodes=[], links=[];
			var delete_bool = false;
			var count = 0; //to know whether the mouse click was on the source node or on the target node while creating edges.
			var source, target; //source and target nodes while creating edges using mouse clicks.

			var node_types = ["E"];	//to store the node types and display them in selection panel
			var current_node_type = "E";
			var current_node_color = color(1);


			var force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

//svg for main graph
			var svg = d3.select("#viz")
				.append("section")
				.attr("id", "graph_panel")
				.attr("width",width)
				.attr("height", height)
				.style("border", "2px solid black")
				.append("svg");

//svg for selecting node types
			var svg2 = d3.select("#viz")
					.append("aside")
					.attr("id", "selection_panel")
					.attr("width",300)
					.attr("height",600)
					.style("border", "2px solid black");


			var node = svg.selectAll(".node");
			var link = svg.selectAll(".link");

//loading initial graph from json file. This graph can later be modified through the GUI.
			d3.json("../json/43.json", function(error, graph) {
				node_types = graph.node_types;
				console.log(graph);
				console.log(node_types);
				force.nodes(graph.nodes)
				.links(graph.links)
				.start()	//this should never be removed
				.on("tick", tick);
					
				svg.on("click", add_node);

				nodes = force.nodes(),
				links = force.links();
				restart();
				update_selection_panel();
			});



/*************************************** FUNCTIONS ****************************************
* key
* add_node
* delete_node
* add_link
* tick
* node_click
* update
* enter
* exit
* update_selection_panel
*/

//key function			
			function key(datum) {
				return datum.key;
			}

//add node
//add a node by clicking anywhere on the svg canvas. While adding the key to the node, find the max. key existing till then, and add the next no. as the key to the incoming node.
			function add_node() {
				d3.event.stopPropagation();
				var point = d3.mouse(this);
				var new_key = d3.max(nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
				if(!new_key) new_key = 0;
				var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color,group:Math.round(Math.random()*10)};
				nodes.push(node_item);
				restart();
			}

//delete node
			function delete_node(d,i){
				d3.event.stopPropagation();
				var indices_to_be_deleted = [];
				console.log("index of node to be deleted is " + i);
				for(var j=0; j<links.length; j++){	//creating the list of indices of links to be deleted
					if((links[j].source.index === i) || (links[j].target.index === i)){
						indices_to_be_deleted.push(j);
					}
				}
				console.log(indices_to_be_deleted);
				indices_to_be_deleted.reverse();	//reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

				for(var j=0; j<indices_to_be_deleted.length; j++){
					links.splice(indices_to_be_deleted[j],1)	//delete one element i.e. at the index j
				}

				//then delete the node itself
				nodes.splice(i,1);	//delete one node i.e. at the index i.
				restart();

			}

//add link
//add a link by clicking on the source node and the target node
			function add_link(d,i){
				console.log("entered add link");
				d3.event.stopPropagation();
				if(count == 1)	{ //clicked on target 
					target = i;
					target_key = nodes[i].key;
					if (source !== target){
						var new_key = source_key + "-" + target_key; //the link key is depending on its source key and target key
						console.log(new_key);
						links.push({key:new_key, "source":source, "target":target});
						count = 0;
						restart();
				}
			}
					else if (count == 0){	//clicked on source
						source = i;
						source_key = nodes[i].key;
						count = 1;
					}
			}


//tick
				
			function tick() {
				link.attr("x1", function(d) { return d.source.x; })
				    .attr("y1", function(d) { return d.source.y; })
				    .attr("x2", function(d) { return d.target.x; })
				    .attr("y2", function(d) { return d.target.y; });

				node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
			}

//node click
			function node_click(d,i){
				if (delete_bool === true) delete_node(d,i);
				else add_link(d,i);
				restart();
			}

/****** update *********/
			function update(){
				update_links();
				update_nodes();
			}

//update_links
			function update_links(){
				link = link.data(links, key);
			}

//update_nodes
			function update_nodes(){
				node = node.data(nodes, key);
				update_shapes();
				update_labels();
				update_titles();
			}

//update_shapes
			function update_shapes(){
				node_shapes = svg.selectAll("g .node_shape");
				node_shapes
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", node_click);
			}

//update_labels
			function update_labels(){
				node_labels = svg.selectAll("g .node_label");
				node_labels
				.text(function(datum){return datum.label;});
			}

//update_titles
			function update_titles(){
				node_titles = svg.selectAll("g .node_title");
				node_titles
				.text(function(d,i) {return i});
			}

				
/****** enter *********/
			function enter(){
				enter_links();
				enter_nodes();
			}

//enter_links
			function enter_links(){
				link.enter().insert("line",".node")
				.attr("class", "link");
			}

//enter_nodes
			function enter_nodes(){
				gnode = node.enter().append("g")
					.attr("class", "node");

				gnode_circles = gnode.append("circle")
				.attr("class", "node_shape")
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", node_click)
				.call(force.drag);

				gnode.append("text")
				.attr("class", "node_label")
				.attr("fill", "white")
				.attr("text-anchor", "middle")
				.attr("font-family", "calibri")
				.attr("font-size", 13)
				.attr("font-weight", "bold")
				.attr("y", 3.5)
				.style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
				.text(function(datum){return datum.label;});

				gnode.append("title")
				.attr("class", "node_title")
				.text(function(d,i) {return i});
			}
				

/****** exit *********/
			function exit(){
				exit_links();
				exit_nodes();
			}

//exit_links
			function exit_links(){
				link.exit().remove();
			}

//exit_nodes
			function exit_nodes(){
				node.exit().remove();
			}
				
/****** restart *********/
			function restart()
			{
				update();
				enter();
				exit();
				force.start();
			}

/****** update selection panel *********/
			function update_selection_panel(){
				d3.select("#selection_panel").selectAll("p")
				.data(node_types)
				.enter()
				.append("p")
				.text(function(datum,index){
					console.log(this);
					return datum;
				})
				.on("click", function(datum,index){
					current_node_type = node_types[index];
					current_node_color = color(index);
					console.log(d3.rgb(current_node_color));
				})
				.on("mouseover", function(datum,index){
					d3.select(this).style("background-color",color(index));
				})
				.on("mouseout",function(datum,index){
					d3.select(this).style("background-color","white");
				});
			}

/*************************************** HANDLING THE BUTTONS *****************************************/

			$(document).ready(function(){
				$("#save_data").click(function(){
				nodes_copy = [];	//I will copy only some attributes of nodes into this.
				links_copy = [];
				for (var i=0; i<nodes.length; i++)
				{
					nodes_copy[i] = {};
					nodes_copy[i].key = nodes[i].key;
					nodes_copy[i].label = nodes[i].label;
					nodes_copy[i].name = nodes[i].name;
					nodes_copy[i].group = nodes[i].group;
					nodes_copy[i].color = nodes[i].color;
				}
				
				for(var i=0; i<links.length; i++)
				{

					links_copy[i] = {};
					links_copy[i].key = links[i].key;
					links_copy[i].source = links[i].source.index;
					links_copy[i].target = links[i].target.index;
				}
			

					nodes_string = JSON.stringify(nodes_copy);					
					links_string = JSON.stringify(links_copy);
					node_types_string = JSON.stringify(node_types);
					console.log(nodes_string);
					console.log(links_string);
					console.log(node_types_string);
					
					$.ajax({
						type: "POST",
						url: "../php/43.php",
						//data: "name=John&location=Boston&count="+count
						data: {nodes:nodes_string, links: links_string, node_types:node_types_string}
						}).done( function(msg){
							alert( "Data Saved: \n" + msg );
							}).fail( function( xmlHttpRequest, statusText, errorThrown ) {
								alert(
									"Your form submission failed.\n\n"
									+ "XML Http Request: " + JSON.stringify( xmlHttpRequest )
									+ ",\nStatus Text: " + statusText
									+ ",\nError Thrown: " + errorThrown );
								});
				});

//on clicking the button, 'start deleting'
				$("#start_delete_node").click(function(){delete_bool = true;
				console.log(delete_bool);
				d3.select("body").append("text")
				.attr("class","delete_text")
				.text("Click on any node to delete it.");});

//on clicking the button, 'stop deleting'
				$("#stop_delete_node").click(function(){delete_bool = false;
				console.log(delete_bool);
				d3.select(".delete_text").remove();});
				
//on clicking the button, 'add node type'
				d3.select("#add_node_type").on("click",function(){
					var label = prompt("Please specify the name of new type, say, in 1 or 2 letters.","");
					if(!label) label="E";
					node_types.push(label);
					update_selection_panel();

				});

			});

	</script>


