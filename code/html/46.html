	<!DOCTYPE html>
	<meta charset="utf-8">
	<head>
	<link rel=stylesheet href="../css/46.css"/>
	<script type="text/javascript" src="../scripts/d3.js"></script>
<!--	<script src="http://d3js.org/d3.v3.min.js"></script>-->
	<script src="../scripts/jquery.min.js"></script>
	</head>
	<body>
		<div id="viz">
		</div>
		<div id="LHS_div">
		</div>
		<div id="RHS_div">
		</div>
		<div id="buttons" align="center">
			<button id="save_data"> Save the graph </button>
			<button id="start_delete_node"> Start deleting </button>
			<button id="stop_delete_node"> Stop deleting </button>
			<button id="add_node_type"> Add Node Type </button>
		</div>
		<script type="text/javascript">

/*
- adding the 'name' attribute to the Generative grammar rules object in the code and in the json file. 
- Handling the reading and writing of json file accordingly through the code.
- Creating separate svg's for LHS, RHS (will create for NAC later).
- Able to display a particular rule, right now the first rule in the rules panels in the browser :)
- Also able to modify the present graph, present rule etc. and then save them on the server :)
*/


		function Graph(nodes, links){	//Graph constructor
			this.nodes = nodes;
			this.links = links;
			this.count = 0;
		}

			Graph.prototype.restart= restart;
			Graph.prototype.update= update;
			Graph.prototype.update_links= update_links;
			Graph.prototype.update_nodes= update_nodes;
			Graph.prototype.update_shapes= update_shapes;
			Graph.prototype.update_labels= update_labels;
			Graph.prototype.update_titles= update_titles;
			Graph.prototype.enter= enter;
			Graph.prototype.enter_links= enter_links;
			Graph.prototype.enter_nodes= enter_nodes;
			Graph.prototype.exit= exit;
			Graph.prototype.exit_links= exit_links;
			Graph.prototype.exit_nodes= exit_nodes;
			Graph.prototype.key= key;
			Graph.prototype.add_node= add_node;
			Graph.prototype.delete_node= delete_node;
			Graph.prototype.add_link= add_link;
			Graph.prototype.tick= tick;
			Graph.prototype.node_click= node_click;


			var current_LHS_graph = new Graph([],[]);
			var current_RHS_graph = new Graph([],[]);

			var main_graph;	//this is the graph in the graph panel on which grammar rules will be applied
			var generative_grammar = {"rules":[]};

			var width = 600;
			var height = 300;
			var color = d3.scale.category20();

			var lhs_panel_width = 600;
			var lhs_panel_height = 300;
			var rhs_panel_width = 600;
			var rhs_panel_height = 300;


			var delete_bool = false;
			var node_types = ["E"];	//to store the node types and display them in selection panel
			var current_node_type = "E";
			var current_node_color = color(1);

//svg for selecting node types
			var selection_panel_svg = d3.select("#viz")
					.append("aside")
					.attr("id", "selection_panel")
					.attr("width",300)
					.attr("height",300)
					.style("border", "2px solid black");

//loading initial graph from json file. This graph can later be modified through the GUI.
			d3.json("../json/46.json", function(error, dataset) {
				node_types = dataset.node_types;
//				console.log(graph);
//				console.log(node_types);
				main_graph = new Graph(dataset.main_graph.nodes, dataset.main_graph.links);
				generative_grammar_rules = dataset.generative_grammar_rules;
				current_LHS_graph.nodes = generative_grammar_rules[0]["lhs"].nodes;
				current_LHS_graph.links = generative_grammar_rules[0]["lhs"].links;
				current_LHS_graph.svg_container = d3.select("#LHS_div")
					.append("svg")
					.attr("id", "lhs_panel")
					.attr("width",lhs_panel_width)
					.attr("height", lhs_panel_height)
					.style("border", "2px solid black");



				current_RHS_graph.nodes = generative_grammar_rules[0]["rhs"].nodes;
				current_RHS_graph.links = generative_grammar_rules[0]["rhs"].links;
				current_RHS_graph.svg_container = d3.select("#RHS_div")
					.append("svg")
					.attr("id", "rhs_panel")
					.attr("width",rhs_panel_width)
					.attr("height", rhs_panel_height)
					.style("border", "2px solid black");


//				console.log(generative_grammar.rules);

//Drawing main graph in its corresponding panel.
				main_graph.svg_container = d3.select("#viz")
					.append("section")
					.attr("id", "graph_panel")
					.attr("width",width)
					.attr("height", height)
					.style("border", "2px solid black")
					.append("svg");

				main_graph.node = main_graph.svg_container.selectAll(".node");
				main_graph.link = main_graph.svg_container.selectAll(".link");

				main_graph.force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

				main_graph.force.nodes(main_graph.nodes)
				.links(main_graph.links)
				.start()	//this should never be removed
				.on("tick", function(){
					var graph = main_graph;
					graph.tick()});
					
				main_graph.svg_container.on("click", function(){
					var graph = main_graph, this_event = this;
					graph.add_node(this_event)});

				main_graph.nodes = main_graph.force.nodes(),
				main_graph.links = main_graph.force.links();
				main_graph.restart();

//Drawing LHS graph in its corresponding panel
				current_LHS_graph.node = current_LHS_graph.svg_container.selectAll(".node");
				current_LHS_graph.link = current_LHS_graph.svg_container.selectAll(".link");

				current_LHS_graph.force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

				current_LHS_graph.force.nodes(current_LHS_graph.nodes)
				.links(current_LHS_graph.links)
				.start()	//this should never be removed
				.on("tick", function(){
					var graph = current_LHS_graph;
					graph.tick()});
					
				current_LHS_graph.svg_container.on("click", function(){
					var graph = current_LHS_graph, this_event = this;
					graph.add_node(this_event)});

				current_LHS_graph.nodes = current_LHS_graph.force.nodes(),
				current_LHS_graph.links = current_LHS_graph.force.links();
				current_LHS_graph.restart();

//Drawing RHS graph in its corresponding panel
				current_RHS_graph.node = current_RHS_graph.svg_container.selectAll(".node");
				current_RHS_graph.link = current_RHS_graph.svg_container.selectAll(".link");

				current_RHS_graph.force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

				current_RHS_graph.force.nodes(current_RHS_graph.nodes)
				.links(current_RHS_graph.links)
				.start()	//this should never be removed
				.on("tick", function(){
					var graph = current_RHS_graph;
					graph.tick()});
					
				current_RHS_graph.svg_container.on("click", function(){
					var graph = current_RHS_graph, this_event = this;
					graph.add_node(this_event)});

				current_RHS_graph.nodes = current_RHS_graph.force.nodes(),
				current_RHS_graph.links = current_RHS_graph.force.links();
				current_RHS_graph.restart();
//Updating selection panel
				update_selection_panel();
	
			});



/*************************************** FUNCTIONS ****************************************
* key
* add_node
* delete_node
* add_link
* tick
* node_click
* update
* enter
* exit
* update_selection_panel
*/

//key function			
			function key(datum) {
				return datum.key;
			}

//add node
//add a node by clicking anywhere on the svg canvas. While adding the key to the node, find the max. key existing till then, and add the next no. as the key to the incoming node.
			function add_node(this_event) {
				console.log("entered");
				console.log(d3.event);
				d3.event.stopPropagation();
				var point = d3.mouse(this_event);
				var new_key = d3.max(this.nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
				if(!new_key) new_key = 0;
				var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color,group:Math.round(Math.random()*10)};
				this.nodes.push(node_item);
				this.restart();
			}

//delete node
			function delete_node(d,i){
				d3.event.stopPropagation();
				var indices_to_be_deleted = [];
				console.log("index of node to be deleted is " + i);
				for(var j=0; j<this.links.length; j++){	//creating the list of indices of links to be deleted
					if((this.links[j].source.index === i) || (this.links[j].target.index === i)){
						indices_to_be_deleted.push(j);
					}
				}
				console.log(indices_to_be_deleted);
				indices_to_be_deleted.reverse();	//reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

				for(var j=0; j<indices_to_be_deleted.length; j++){
					this.links.splice(indices_to_be_deleted[j],1)	//delete one element i.e. at the index j
				}

				//then delete the node itself
				this.nodes.splice(i,1);	//delete one node i.e. at the index i.
				this.restart();

			}

//add link
//add a link by clicking on the source node and the target node
			function add_link(d,i){
				console.log("entered add link");
				d3.event.stopPropagation();
				if(this.count == 1)	{ //clicked on target 
					this.target = i;
					this.target_key = this.nodes[i].key;	//I had to do this.target_key (not just target_key) because once it leaves this loop, the target_key should still be stored, but I dont want it to be a global variable.
					if (this.source !== this.target){
						var new_key = this.source_key + "-" + this.target_key; //the link key is depending on its source key and target key
						console.log(new_key);
						this.links.push({key:new_key, "source":this.source, "target":this.target});
						this.count = 0;
						this.restart();
				}
			}
					else if (this.count == 0){	//clicked on source
						this.source = i;
						this.source_key = this.nodes[i].key;
						this.count = 1;
					}
			}


//tick
				
			function tick() {
//				console.log(this);
				this.link.attr("x1", function(d) { return d.source.x; })
				    .attr("y1", function(d) { return d.source.y; })
				    .attr("x2", function(d) { return d.target.x; })
				    .attr("y2", function(d) { return d.target.y; });

				this.node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
			}

//node click
			function node_click(d,i){
				if (delete_bool === true) this.delete_node(d,i);
				else this.add_link(d,i);
				this.restart();
			}

/****** update *********/
			function update(){
				this.update_links();
				this.update_nodes();
			}

//update_links
			function update_links(){
				this.link = this.link.data(this.links, this.key);
			}

//update_nodes
			function update_nodes(){
				this.node = this.node.data(this.nodes, this.key);
				this.update_shapes();
				this.update_labels();
				this.update_titles();
			}

//update_shapes
			function update_shapes(){
				var graph = this;
				var node_shapes = this.svg_container.selectAll("g .node_shape");
				node_shapes
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", function(datum, index){
					graph.node_click(datum, index);});
			}

//update_labels
			function update_labels(){
				var node_labels = this.svg_container.selectAll("g .node_label");
				node_labels
				.text(function(datum){return datum.label;});
			}

//update_titles
			function update_titles(){
				var node_titles = this.svg_container.selectAll("g .node_title");
				node_titles
				.text(function(d,i) {return i});
			}

				
/****** enter *********/
			function enter(){
				this.enter_links();
				this.enter_nodes();
			}

//enter_links
			function enter_links(){
				this.link.enter().insert("line",".node")
				.attr("class", "link");
			}

//enter_nodes
			function enter_nodes(){
				var graph = this;
				console.log(this);
				var gnode = this.node.enter().append("g")
					.attr("class", "node");

				var gnode_circles = gnode.append("circle")
				.attr("class", "node_shape")
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", function(datum, index){
					graph.node_click(datum, index);})
				.call(graph.force.drag);

				gnode.append("text")
				.attr("class", "node_label")
				.attr("fill", "white")
				.attr("text-anchor", "middle")
				.attr("font-family", "calibri")
				.attr("font-size", 13)
				.attr("font-weight", "bold")
				.attr("y", 3.5)
				.style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
				.text(function(datum){return datum.label;});

				gnode.append("title")
				.attr("class", "node_title")
				.text(function(d,i) {return i});
			}
				

/****** exit *********/
			function exit(){
				this.exit_links();
				this.exit_nodes();
			}

//exit_links
			function exit_links(){
				this.link.exit().remove();
			}

//exit_nodes
			function exit_nodes(){
				this.node.exit().remove();
			}
				
/****** restart *********/
			function restart()
			{
				this.update();
				this.enter();
				this.exit();
				this.force.start();
			}

/****** update selection panel *********/
			function update_selection_panel(){
				d3.select("#selection_panel").selectAll("p")
				.data(node_types)
				.enter()
				.append("p")
				.text(function(datum,index){
					console.log(this);
					return datum;
				})
				.on("click", function(datum,index){
					current_node_type = node_types[index];
					current_node_color = color(index);
					console.log(d3.rgb(current_node_color));
				})
				.on("mouseover", function(datum,index){
					d3.select(this).style("background-color",color(index));
				})
				.on("mouseout",function(datum,index){
					d3.select(this).style("background-color","white");
				});
			}


/*************************************** HANDLING THE BUTTONS *****************************************/

			$(document).ready(function(){
				$("#save_data").click(function(){
				main_graph_nodes_copy = [];	//I will copy only some attributes of nodes into this.
				main_graph_links_copy = [];
				for (var i=0; i<main_graph.nodes.length; i++)
				{
					main_graph_nodes_copy[i] = {};
					main_graph_nodes_copy[i].key = main_graph.nodes[i].key;
					main_graph_nodes_copy[i].label = main_graph.nodes[i].label;
					main_graph_nodes_copy[i].name = main_graph.nodes[i].name;
					main_graph_nodes_copy[i].group = main_graph.nodes[i].group;
					main_graph_nodes_copy[i].color = main_graph.nodes[i].color;
				}
				
				for(var i=0; i<main_graph.links.length; i++)
				{

					main_graph_links_copy[i] = {};
					main_graph_links_copy[i].key = main_graph.links[i].key;
					main_graph_links_copy[i].source = main_graph.links[i].source.index;
					main_graph_links_copy[i].target = main_graph.links[i].target.index;
				}
			

				node_types_string = JSON.stringify(node_types);

				main_graph_object = {"nodes":main_graph_nodes_copy,"links":main_graph_links_copy};
				main_graph_string = JSON.stringify(main_graph_object);
				console.log(main_graph_string);
				console.log(node_types_string);

				generative_grammar_rules_array = []
//				generative_grammar_rules = generative_grammar.rules;
				for(var i=0; i<generative_grammar_rules.length; i++){
					generative_grammar_rules_array[i] = {};
					generative_grammar_rules_array[i].name = generative_grammar_rules[i].name;
					console.log(generative_grammar_rules[i]);
					console.log(generative_grammar_rules[i]["lhs"].nodes.length);
					arr = ["lhs","rhs","nac"];
					for(var j in arr){
						generative_grammar_rules_array[i][arr[j]] = {};
						var nodes_copy = [];
//						console.log(generative_grammar_rules[i][arr[j]]);
						for(var k in generative_grammar_rules[i][arr[j]].nodes){
							console.log("entered " + k + " times");
							nodes_copy[k] = {};
							nodes_copy[k].key = generative_grammar_rules[i][arr[j]].nodes[k].key;
							nodes_copy[k].label = generative_grammar_rules[i][arr[j]].nodes[k].label;
							nodes_copy[k].name = generative_grammar_rules[i][arr[j]].nodes[k].name;
							nodes_copy[k].group = generative_grammar_rules[i][arr[j]].nodes[k].group;
							nodes_copy[k].color = generative_grammar_rules[i][arr[j]].nodes[k].color;
						}
						console.log(nodes_copy);
						generative_grammar_rules_array[i][arr[j]].nodes = nodes_copy;
						console.log(generative_grammar_rules_array[i][arr[j]].nodes);
						console.log(generative_grammar_rules[i][arr[j]].nodes);
						var links_copy = [];
						for(var k in generative_grammar_rules[i][arr[j]].links){
							links_copy[k] = {};
							links_copy[k].key = generative_grammar_rules[i][arr[j]].links[k].key;
							links_copy[k].source = generative_grammar_rules[i][arr[j]].links[k].source.index;
							links_copy[k].target = generative_grammar_rules[i][arr[j]].links[k].target.index;
						}
						generative_grammar_rules_array[i][arr[j]].links = links_copy;
					}
				}
//				console.log(generative_grammar_rules_array);

				generative_grammar_rules_string = JSON.stringify(generative_grammar_rules_array);
					
					$.ajax({
						type: "POST",
						url: "../php/46.php",
						//data: "name=John&location=Boston&count="+count
					//	data: {nodes:main_graph_nodes_string, links: main_graph_links_string, node_types:node_types_string}
						data: {main_graph:main_graph_string, node_types:node_types_string, generative_grammar_rules: generative_grammar_rules_string}
						}).done( function(msg){
							alert( "Data Saved: \n" + msg );
							}).fail( function( xmlHttpRequest, statusText, errorThrown ) {
								alert(
									"Your form submission failed.\n\n"
									+ "XML Http Request: " + JSON.stringify( xmlHttpRequest )
									+ ",\nStatus Text: " + statusText
									+ ",\nError Thrown: " + errorThrown );
								});
				});

//on clicking the button, 'start deleting'
				$("#start_delete_node").click(function(){delete_bool = true;
				console.log(delete_bool);
				d3.select("body").append("text")
				.attr("class","delete_text")
				.text("Click on any node to delete it.");});

//on clicking the button, 'stop deleting'
				$("#stop_delete_node").click(function(){delete_bool = false;
				console.log(delete_bool);
				d3.select(".delete_text").remove();});
				
//on clicking the button, 'add node type'
				d3.select("#add_node_type").on("click",function(){
					var label = prompt("Please specify the name of new type, say, in 1 or 2 letters.","");
					if(!label) label="E";
					node_types.push(label);
					update_selection_panel();

				});

			});

	</script>


