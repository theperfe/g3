<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link rel=stylesheet href="../css/61.css"/>
<script type="text/javascript" src="../scripts/d3.js"></script>
<!--  <script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="../scripts/jquery.min.js"></script>
<script src="../scripts/my_functions.js"></script>
</head>
<body>

  <div id="left_panel">
    <div id="rules_names_panel">
      <h4> Rules </h4>
    </div>
    <div id="graphs_names_panel">
      <h4> Graphs </h4>
    </div>
  </div>
  <div id="central_panel">
    <div id = "tabs_panel">
    </div>
    <div class="clear">
    </div>
    <div id = "rendering_panel">
    </div>
  </div>
  <div id = "right_panel">
    <div id = "node_types_panel">
      <h4> Node Types </h4>
    </div>
    <div id = "link_types_panel">
      <h4> Link Types </h4>
    </div>
  </div>
  <div class = "clear">
  </div>
  <div id="buttons_panel" align="center">
    <button id="save_data"> Save the graph </button>
    <button id="add_node_type"> Add node type </button>
    <button id="add_link_type"> Add link type </button>
    <button id="new_rule"> New rule </button>
    <button id="new_graph"> New graph </button>
  </div>

  <script type="text/javascript">


/*************************************** VARIABLES *****************************************/

    var generative_grammar_rules = [], graphs = [];
    var rules_names = [], graphs_names = [];
    var current_graph = new Graph([],[]); //because the current graph in the rendering panel can either be main graph or the current rule graph
    current_graph.index = {"name":"Main Graph", "Main Graph":0, "Rule Graph":0};
    var current_rule_name = null, current_graph_name = null;

    var all_graphs_obj = {"Main Graph": null, "Rule Graph": null};
    var tabs = [];
    for(var i in all_graphs_obj){ tabs.push(i);}
    var current_tab = tabs[0];

    var soft_buttons = ["Add mode", "Delete mode"];
    var current_soft_button = soft_buttons[0];

    var width = 700;
    var height = 570;
    var color = d3.scale.category20();

    var current_node_type = null;
    var current_node_color = color(0);

    current_graph.svg_container = d3.select("#rendering_panel").append("svg");
    current_graph.svg_container
      .append("svg:defs")
        .append("svg:marker")
          .attr('id', 'end-arrow')
	  .attr('viewBox', '0 -5 10 10')
	  .attr('refX',4)
	  .attr('markerWidth', 3)
	  .attr('markerHeight', 3)
	  .attr('orient', 'auto')
	.append("svg:path")
	  .attr('d', 'M0,-5L10,0L0,5')
	  .attr('fill', '#000');


/*************************************** MAIN CODE *****************************************/
    d3.json("../json/61.json", function(error, dataset) {
      dataset.graphs.forEach(function(element){graphs_names.push(element.name);});
      graphs = dataset.graphs;
      current_graph_name = dataset.graphs[0].name;
      try{
        generative_grammar_rules = dataset.generative_grammar_rules;
        for(var i=0; i<generative_grammar_rules.length; i++){
          rules_names.push(generative_grammar_rules[i].name);
        }
	current_rule_name = generative_grammar_rules[0].name || null;
      }
      catch(error){
      }
      all_graphs_obj["Main Graph"] = graphs;
      all_graphs_obj["Rule Graph"] = generative_grammar_rules;

      current_graph.node = current_graph.svg_container.append("svg:g").selectAll(".node");
      current_graph.link = current_graph.svg_container.append("svg:g").selectAll(".link");
      current_graph.force = d3.layout.force()
      				     .size([width, height])
				     .charge(-100)
				     .linkDistance(60);

      current_node_type = graphs[0].node_types[0];
      initialize_graph(current_graph, graphs[0]);
      console.log(current_graph);
      current_graph.force.on("tick", function(){ current_graph.tick();});
      current_graph.svg_container.on("click", function(){
      					var this_event = this;
					if(current_graph.index.name == "Main Graph") current_graph.add_node_in_main_graph(this_event);
					else current_graph.add_node(this_event);});
//      current_graph.restart();

//Updating different panels
      current_graph.update_node_types_panel();
      update_rules_names_panel();
      update_soft_buttons_panel();
      update_graphs_names_panel();
      update_tabs_panel();
    });

/*************************************** FUNCTIONS ****************************************
* soft button constructor
* graph constructor
* key
* initialize graph
* add_node
* delete_node
* add_link
* tick
* node_click
* update
* enter
* exit
* update_node_types_panel
*/

//soft button constructor
  function Soft_button(){
    this.active = false;
  }

//Tab constructor
  function Tab(){
    this.active = false;
  }

//Graph constructor

  function Graph(nodes, links){  //Graph constructor
    this.nodes = nodes;
    this.links = links;
    this.count = 0;
    this.node_types = [];
  }

    Graph.prototype.restart= restart;
    Graph.prototype.update= update;
    Graph.prototype.update_links= update_links;
    Graph.prototype.update_nodes= update_nodes;
    Graph.prototype.update_shapes= update_shapes;
    Graph.prototype.update_labels= update_labels;
    Graph.prototype.update_labels_in_main_graph= update_labels_in_main_graph;
    Graph.prototype.update_titles= update_titles;
    Graph.prototype.enter= enter;
    Graph.prototype.enter_links= enter_links;
    Graph.prototype.enter_nodes= enter_nodes;
    Graph.prototype.enter_nodes_in_main_graph= enter_nodes_in_main_graph;
    Graph.prototype.exit= exit;
    Graph.prototype.exit_links= exit_links;
    Graph.prototype.exit_nodes= exit_nodes;
    Graph.prototype.key= key;
    Graph.prototype.add_node= add_node;
    Graph.prototype.add_node_in_main_graph= add_node_in_main_graph;
    Graph.prototype.delete_node= delete_node;
    Graph.prototype.delete_node_type= delete_node_type;
    Graph.prototype.update_node_types_panel= update_node_types_panel;
    Graph.prototype.delete_link= delete_link;
    Graph.prototype.add_link= add_link;
    Graph.prototype.tick= tick;
    Graph.prototype.node_click= node_click;
    Graph.prototype.link_click= link_click;
    Graph.prototype.transform_graph = transform_graph;
    Graph.prototype.match = match;
//    Graph.prototype.replace = replace;
 //   Graph.prototype.predecessors = predecessors;
  //  Graph.prototype.successors = successors;

//key function      
    function key(datum) {
      return datum.key;
    }

//initialize graph
    function initialize_graph(graph1, graph2){
	graph1.nodes = graph2.nodes;
	graph1.links = graph2.links;
	graph1.node_types = graph2.node_types; 
	graph1.force.nodes(graph1.nodes)
	    			.links(graph1.links)
				.start();
	    
	graph1.nodes = graph1.force.nodes();
	graph1.links = graph1.force.links();
        graph1.force.on("tick", function(){ graph1.tick();});
        graph1.svg_container.on("click", function(){
      					var this_event = this;
					if(graph1.index.name == "Main Graph") graph1.add_node_in_main_graph(this_event);
					else graph1.add_node(this_event);});
	graph1.restart();
    }

//add node
//add a node by clicking anywhere on the svg canvas. While adding the key to the node, find the max. key existing till then, and add the next no. as the key to the incoming node.
    function add_node(this_event) {
      d3.event.stopPropagation();
      var point = d3.mouse(this_event);
      var node_width = 18, node_height = 18, line1 = '', line2 = '', line1_color = "black", line2_color = "black";
      var definition = prompt("Please specify the definition of this node");
      if(definition === false) return;
      while(definition === "") definition = prompt("The definition cannot be empty. Please specify a proper definition of this node");
      var possible_new_node_types = [];
      switch(true){
        case (definition.slice(0,5) === "new::"):
	  current_node_color = "green";
	  current_node_type = definition.slice(10);
	  possible_new_node_types.push(current_node_type);
	  line1 = definition.slice(10);
	  line1_color = "green";
	  node_width = current_node_type.length*10+8;
	  break;
	case (definition.slice(0,5) === "del::"):
	  current_node_color = "blue";
	  current_node_type = definition.slice(10);
	  possible_new_node_types.push(current_node_type);
	  line1 = definition.slice(10);
	  line1_color = "blue";
	  node_width = current_node_type.length*10+8;
	  break;
	case (!!(definition.match(/^new:type:.*;del:type:.*/))):	//to evaluate the value to true or false
	  current_node_color = "black";
	  current_node_type = "+" + definition.slice(9,definition.indexOf(';')) + "-" + definition.slice(definition.indexOf('del:')+9);
	  line1 = "+" + definition.slice(9,definition.indexOf(';'));
	  possible_new_node_types.push(definition.slice(9,definition.indexOf(';')));
	  line1_color = "green";
	  line2 = "-" + definition.slice(definition.indexOf('del:')+9);
	  possible_new_node_types.push(definition.slice(definition.indexOf('del:')+9));
	  line2_color = "blue";
	  if(line1.length > line2.length)
	    node_width = line1.length*10+8;
	  else node_width = line2.length*10+8;
	  node_height = 30;
	  break;
	case (!!(definition.match(/^del:type:.*;new:type:.*/))):	//to evaluate the value to true or false
	  current_node_color = "black";
	  current_node_type = "-" + definition.slice(9,definition.indexOf(';')) + "+" + definition.slice(definition.indexOf('new:')+9);
	  line1 = "-" + definition.slice(9,definition.indexOf(';'));
	  possible_new_node_types.push(definition.slice(9,definition.indexOf(';')));
	  line1_color = "blue";
	  line2 = "+" + definition.slice(definition.indexOf('new:')+9);
	  possible_new_node_types.push(definition.slice(definition.indexOf('new:')+9));
	  line2_color = "green";
	  if(line1.length > line2.length)
	    node_width = line1.length*10+8;
	  else node_width = line2.length*10+8;
	  node_height = 30;
	  break;
	case (definition.slice(0,4) === "new:"):
	  current_node_color = "black";
	  current_node_type = "+" + definition.slice(9);
	  possible_new_node_types.push(definition.slice(9));
	  line1 = "+" + definition.slice(9);
	  line1_color = "green";
	  node_width = current_node_type.length*10+8;
	  break;
	case (definition.slice(0,4) === "del:"):
	  current_node_color = "black";
	  current_node_type = "-" + definition.slice(9);
	  possible_new_node_types.push(definition.slice(9));
	  line1 = "-" + definition.slice(9);
	  line1_color = "blue";
	  node_width = current_node_type.length*10+8;
	  break;
	case (definition.slice(0,4) === "type"):
	  current_node_color = "black";
	  current_node_type = definition.slice(5);
	  possible_new_node_types.push(current_node_type);
	  line1 = definition.slice(5);
	  node_width = current_node_type.length*10+8;
	  break;
	default:
	  alert("Wrong definition. Try again.");
      }
      for(var i in possible_new_node_types){
        if(this.node_types.indexOf(possible_new_node_types[i]) == -1){
	  this.node_types.push(possible_new_node_types[i]);
	  this.update_node_types_panel();
        }
      }
      var new_key = d3.max(this.nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
      if(!new_key) new_key = 0;
      var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color, width: node_width, height: node_height, definition: definition, line1: line1, line2: line2, line1_color: line1_color, line2_color: line2_color};
      this.nodes.push(node_item);
      this.restart();
    }

    function add_node_in_main_graph(this_event) {
      d3.event.stopPropagation();
      var point = d3.mouse(this_event);
      if(this.node_types.length == 0){
        alert("You should add at least one node type before adding a node in the graph");
	return;
      }
      var new_key = d3.max(this.nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
      if(!new_key) new_key = 0;
      var node_width = 18, node_height = 18;
      var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color, width: node_width, height: node_height};
      this.nodes.push(node_item);
      this.restart();
    }

//delete node
    function delete_node(d,i){
      d3.event.stopPropagation();
      var indices_to_be_deleted = [];
      for(var j=0; j<this.links.length; j++){  //creating the list of indices of links to be deleted
        if((this.links[j].source.index == i) || (this.links[j].target.index == i)){
          indices_to_be_deleted.push(j);
        }
      }
      indices_to_be_deleted.reverse();  //reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

      for(var j=0; j<indices_to_be_deleted.length; j++){
        this.links.splice(indices_to_be_deleted[j],1)  //delete one element i.e. at the index j
      }

      //then delete the node itself
      this.nodes.splice(i,1);  //delete one node i.e. at the index i.
      this.restart();
      this.restart();

    }

//add link
//add a link by clicking on the source node and the target node
    function add_link(d,i){
      d3.event.stopPropagation();
      if(this.count == 1)  { //clicked on target 
        this.target = i;
        this.target_key = this.nodes[i].key;  //I had to do this.target_key (not just target_key) because once it leaves this loop, the target_key should still be stored, but I dont want it to be a global variable.
        if (this.source !== this.target){
          var new_key = this.source_key + "-" + this.target_key; //the link key is depending on its source key and target key
	  var check = false;		
	  this.links.forEach(function(link){
	    if(link.key == new_key) check = true;}); 
	  if(check === true){
	    this.count = 0;
	    alert("A link already exists between these two nodes.");
	  }
	  else{
	    var link_item = {key:new_key, source:this.source, target:this.target};
	    console.log(link_item);
            this.links.push(link_item);
            this.count = 0;
            this.restart();
	  }
        }
      }
        else if (this.count == 0){  //clicked on source
          this.source = i;
          this.source_key = this.nodes[i].key;
          this.count = 1;
        }
    }
    
//delete link
    function delete_link(d,i){
      d3.event.stopPropagation();
      this.links.splice(i,1);
      this.restart();
    }

//tick
      
    function tick() {
      this.link.attr('d', function(d) {
		    var deltaX = d.target.x - d.source.x,
		    deltaY = d.target.y - d.source.y,
		    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
		    normX = deltaX / dist,
		    normY = deltaY / dist,
		    sourceXPadding = d.source.width/2 ,
		    sourceYPadding = d.source.height/2 ,
		    targetXPadding = d.target.width/2 + 6,
		    targetYPadding = d.target.height/2 + 6,
		    sourceX = d.source.x + d.source.width/2 + (sourceXPadding * normX),
		    sourceY = d.source.y + d.source.height/2 + (sourceYPadding * normY),
		    targetX = d.target.x + d.target.width/2 - (targetXPadding * normX),
		    targetY = d.target.y + d.target.height/2 - (targetYPadding * normY);

		    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
      });

      this.node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
    }

//node click
    function node_click(d,i){
      if (current_soft_button === "Delete mode") this.delete_node(d,i);
      else this.add_link(d,i);
      this.restart();
    }

//link click
    function link_click(d,i){
      console.log("entered");
      d3.event.stopPropagation();
      if(current_soft_button === "Delete mode") this.delete_link(d,i);
      this.restart();
    }

//transform graph
    function transform_graph(lhs, rhs){	//transform the given graph using the rule given as argument
      if(this.match(lhs)) this.replace(rhs);
    }

//match graph
    function match(graph){
    }

/****** update *********/
    function update(){
      this.update_links();
      this.update_nodes();
    }

//update_links
    function update_links(){
      var graph = this;
      this.link = this.link.data(this.links, this.key)
      .on("click", function(datum, index){
        graph.link_click(datum, index);});
    }

//update_nodes
    function update_nodes(){
      this.node = this.node.data(this.nodes, this.key);
      this.update_shapes();
      if(this.index.name == "Main Graph") this.update_labels_in_main_graph();
      else this.update_labels();
      this.update_titles();
    }

//update_shapes
    function update_shapes(){
      var graph = this;
      var node_shapes = this.svg_container.selectAll("g .node_shape").data(this.nodes, this.key);
      node_shapes
      .attr("fill", "white")
      .style("stroke", function(d){ return d.color})
      .on("click", function(datum, index){
        graph.node_click(datum, index);});
    }

//update_labels in main graph
    function update_labels_in_main_graph(){
      var node_labels = this.svg_container.selectAll("g text.node_label").data(this.nodes, this.key);
      node_labels
      .text(function(datum){return datum.label;});
    }

//update_labels in rules graph
    function update_labels(){
      var line1_labels = this.svg_container.selectAll("g g.node_label .line1").data(this.nodes, this.key);
      line1_labels
      .text(function(datum) {return datum.line1;})
      .attr("fill", function(datum) {return datum.line1_color;});
      var line2_labels = this.svg_container.selectAll("g g.node_label .line2").data(this.nodes, this.key);
      line2_labels
      .text(function(datum) {return datum.line2;})
      .attr("fill", function(datum) {return datum.line2_color;});
    }

//update_titles
    function update_titles(){
      var node_titles = this.svg_container.selectAll("g .node_title").data(this.nodes, this.key);
      node_titles
      .text(function(d,i) {return i});
    }
      
/****** enter *********/
    function enter(){
      this.enter_links();
      if(this.index.name == "Main Graph") this.enter_nodes_in_main_graph();
      else this.enter_nodes();
    }

//enter_links
    function enter_links(){
      var graph = this;
      this.link.enter().append("svg:path")
      .attr("class", "link")
      .style('marker-end', function(d){return 'url(#end-arrow)';})
      .on("click", function(datum, index){
        graph.link_click(datum, index);});
    }

//enter_nodes in main graph
    function enter_nodes_in_main_graph(){
      var graph = this;
      var gnode = this.node.enter().append("g")
        .attr("class", "node");

      gnode.append("rect")
      .attr("class", "node_shape")
      .attr("width", function(d){return d.width;})
      .attr("height", function(d){return d.height;})
      .attr("fill", "white")
      .style("stroke", function(d){ return d.color})
      .on("click", function(datum, index){
        graph.node_click(datum, index);})
      .call(graph.force.drag);

      gnode.append("text")
      .attr("class", "node_label")
      .attr("fill", "black")
//      .attr("text-anchor", "middle")
      .attr("font-family", "calibri")
      .attr("font-size", 13)
      .attr("font-weight", "bold")
      .attr("x", 4)
      .attr("y", 12)
      .style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
      .text(function(datum){return datum.label;});

      gnode.append("title")
      .attr("class", "node_title")
      .text(function(d,i) {return i});
    }

//enter_nodes in rules graph
    function enter_nodes(){
      var graph = this;
      var gnode = this.node.enter().append("g")
        .attr("class", "node");

      gnode.append("rect")
      .attr("class", "node_shape")
      .attr("width", function(d){return d.width;})
      .attr("height", function(d){return d.height;})
      .attr("fill", "white")
      .style("stroke", function(d){ return d.color})
      .on("click", function(datum, index){
        graph.node_click(datum, index);})
      .call(graph.force.drag);

      gnode2 = gnode.append("g").attr("class", "node_label");
      
      gnode2.append("text")
      .attr("class", "line1")
      .attr("fill", function(datum){return datum.line1_color;})
      .attr("font-family", "calibri")
      .attr("font-size", 13)
      .attr("font-weight", "bold")
      .attr("x", 4)
      .attr("y", 12)
      .style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
      .text(function(datum){return datum.line1;});

      gnode2.append("text")
      .attr("class", "line2")
      .attr("fill", function(datum){return datum.line2_color;})
      .attr("font-family", "calibri")
      .attr("font-size", 13)
      .attr("font-weight", "bold")
      .attr("x", 4)
      .attr("y", 28)
      .style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
      .text(function(datum){return datum.line2;});

      gnode.append("title")
      .attr("class", "node_title")
      .text(function(d,i) {return i});
    }



/****** exit *********/
    function exit(){
      this.exit_links();
      this.exit_nodes();
    }

//exit_links
    function exit_links(){
      this.link.exit().remove();
    }

//exit_nodes
    function exit_nodes(){
      this.node.exit().remove();
    }
      
/****** restart *********/
    function restart()
    {
      this.update();
      this.enter();
      this.exit();
      this.force.start();
    }

/****** update node types panel *********/
    function update_node_types_panel(){
      var graph = this;
      var ntypes = d3.select("#node_types_panel").selectAll("p").data(this.node_types);

    //update existing node types
      ntypes.classed('selected', function(datum) {return datum === current_node_type;})
      .text(function(datum,index){
        return datum;
      });

    //add new node types
      ntypes.enter()
      .append("p")
      .classed('selected', function(datum) {return datum === current_node_type;})
      .text(function(datum,index){
        return datum;
      })
      .on("click", function(datum,index){
        if (current_soft_button === "Delete mode") graph.delete_node_type(datum, index);
	else{
          current_node_type = datum;
          current_node_color = color(index);
	  graph.update_node_types_panel();
	}
      });

      //exit node types
      ntypes.exit().remove();
    }

//delete node type
    function delete_node_type(datum, index){
      var check = function(){
          for(var j in this.nodes){
	    if(datum === this.nodes[j].label) return true;
  	  }
        return false;
      }
      if(check() === false){
        this.node_types.splice(index, 1);
	this.update_node_types_panel();
      }
      else{
        var answer = confirm("There are nodes based on this node type. If you delete this node type, all those nodes will be deleted. Would you like to continue?");
	if(answer === true){
            for(var j in this.nodes){
	      if(datum === this.nodes[j].label){
	        this.delete_node(this.nodes[j],j);
		console.log(j);
	      }
  	    }
	  this.restart();
	  this.node_types.splice(index,1);
	  this.update_node_types_panel();
        }
      }
    }

/****** update rules names panel *********/
    function update_rules_names_panel(){

      var rnames = d3.select("#rules_names_panel").selectAll("p").data(rules_names);
      
      //update rules names
      rnames.classed('selected', function(datum){return datum === current_rule_name;})
      .text(function(datum){return datum});

      //add new rules names
      rnames.enter()
      .append("p")
      .classed('selected', function(datum){return datum === current_rule_name;})
      .text(function(datum){return datum})
      .on("click", function(datum, index){
        if(current_soft_button === "Delete mode") delete_rule_name(datum, index);
	else{
	  current_tab = "Rule Graph";
	  update_tabs_panel();
          current_rule_name = datum;
	  current_graph.index.name = "Rule Graph";
	  current_graph.index[current_graph.index.name] = index;
	  initialize_graph(current_graph, generative_grammar_rules[index]);
//	  current_graph.restart();
	  update_rules_names_panel();
	  current_graph.update_node_types_panel();
	}
      });

      //exit rules names
      rnames.exit().remove();
    }

//delete rule name
    function delete_rule_name(datum, index){
      rules_names.splice(index,1);
      generative_grammar_rules.splice(index,1);
      update_rules_names_panel();
    }

/****** update graphs names panel *********/
    function update_graphs_names_panel(){

      var gnames = d3.select("#graphs_names_panel").selectAll("p").data(graphs_names);
      
      //update rules names
      gnames.classed('selected', function(datum){return datum === current_graph_name;})
      .text(function(datum){return datum});

      //add new rules names
      gnames.enter()
      .append("p")
      .classed('selected', function(datum){return datum === current_graph_name;})
      .text(function(datum){return datum})
      .on("click", function(datum, index){
        if(current_soft_button === "Delete mode") delete_graph_name(datum, index);
	else{
	  current_tab = "Main Graph";
	  update_tabs_panel();
          current_graph_name = datum;
	  current_graph.index.name = "Main Graph";
	  current_graph.index[current_graph.index.name] = index;
	  initialize_graph(current_graph, graphs[index]);
//	  current_graph.restart();
	  update_graphs_names_panel();
	  current_graph.update_node_types_panel();
	}
      });

      //exit rules names
      gnames.exit().remove();
    }

//delete graph name
    function delete_graph_name(datum, index){
      graphs_names.splice(index,1);
      graphs.splice(index,1);
      update_graphs_names_panel();
    }


/************** update soft buttons panel **************/
    function update_soft_buttons_panel(){
      var snames = d3.select("#buttons_panel").selectAll(".soft_button").data(soft_buttons);

      //update soft_buttons panel
        snames.classed("selected_soft_button", function(datum){return current_soft_button === datum;})
	.text(function(datum){return datum;});

      //add soft_buttons
        snames.enter()
	.append("div")
	.attr("class", "soft_button")
	.classed("selected_soft_button", function(datum){return current_soft_button === datum;})
	.attr("id", function(datum) {return datum;})
	.text(function(datum){return datum;})
	.on("click", function(datum){
	  current_soft_button = datum;
	  update_soft_buttons_panel();
	});

      //remove soft_buttons
        snames.exit().remove();
    }

/************** update tabs panel **************/
    function update_tabs_panel(){
      var tnames = d3.select("#tabs_panel").selectAll(".tab").data(tabs);

      //update tabs panel
        tnames.classed("selected_tab", function(datum){return current_tab === datum;})
	.text(function(datum){return datum;});

      //add tabs
        tnames.enter()
	.append("div")
	.attr("class", "tab")
	.classed("selected_tab", function(datum){return current_tab === datum;})
	.attr("id", function(datum) {return datum;})
	.text(function(datum){return datum;})
	.on("click", function(datum, index){
	  current_tab = datum;
	  current_graph.index.name = datum;
	  initialize_graph(current_graph, all_graphs_obj[datum][current_graph.index[datum]]);
	  //current_graph.restart();
	  update_tabs_panel();
	  current_graph.update_node_types_panel();
	});

      //remove tabs
        tnames.exit().remove();
    }



/*************************************** HANDLING THE BUTTONS *****************************************/

    $(document).ready(function(){
      $("#save_data").click(function(){
        var graphs_copy = [];  //I will copy only some attributes of nodes and links of each graph. Hence this copy array.
        for(var i=0; i<graphs.length; i++){
          graphs_copy[i] = {};
      	  graphs_copy[i].name = graphs[i].name;
  	  graphs_copy[i].node_types = graphs[i].node_types;
	  graphs_copy[i].nodes = [];
	  graphs[i].nodes.forEach(function(element){
	    graphs_copy[i].nodes.push({
	      key: element.key,
	      label: element.label,
	      name: element.name,
  	      color: element.color,
	      width: element.width,
	      height: element.height
	    });
	  });
	  graphs_copy[i].links = [];
	  graphs[i].links.forEach(function(element){
	    if(typeof element.source == "object"){		//if the graph was passed to force.links() function
	      graphs_copy[i].links.push({
	        key: element.key,
	        source: element.source.index,
	        target: element.target.index
	      });
	    }
	    else graphs_copy[i].links.push(element);
	  });
        }
      
        graphs_string = JSON.stringify(graphs_copy);

        var generative_grammar_rules_copy = [];  //I will copy only some attributes of nodes and links of each graph. Hence this copy array.
        for(var i=0; i<generative_grammar_rules.length; i++){
          generative_grammar_rules_copy[i] = {};
	  generative_grammar_rules_copy[i].name = generative_grammar_rules[i].name;
	  generative_grammar_rules_copy[i].node_types = generative_grammar_rules[i].node_types;
	  generative_grammar_rules_copy[i].nodes = [];
	  generative_grammar_rules[i].nodes.forEach(function(element){
	    generative_grammar_rules_copy[i].nodes.push({
	      key: element.key,
	      label: element.label,
	      name: element.name,
	      color: element.color,
	      width: element.width,
	      height: element.height,
	      definition: element.definition,
	      line1: element.line1,
	      line2: element.line2,
	      line1_color: element.line1_color,
	      line2_color: element.line2_color
	    });
	  });
	  generative_grammar_rules_copy[i].links = [];
	  generative_grammar_rules[i].links.forEach(function(element){
	    if(typeof element.source == "object"){		//if the graph was passed to force.links() function
	      generative_grammar_rules_copy[i].links.push({
	        key: element.key,
	        source: element.source.index,
	        target: element.target.index
  	      });
	    }
	    else generative_grammar_rules_copy[i].links.push(element);
	  });
        }

        generative_grammar_rules_string = JSON.stringify(generative_grammar_rules_copy);

        $.ajax({
          type: "POST",
          url: "../php/61.php",
          data: {graphs:graphs_string, generative_grammar_rules: generative_grammar_rules_string}
          }).done( function(msg){
            alert( "Data Saved: \n" + msg );
            }).fail( function( xmlHttpRequest, statusText, errorThrown ) {
              alert(
                "Your form submission failed.\n\n"
                + "XML Http Request: " + JSON.stringify( xmlHttpRequest )
                + ",\nStatus Text: " + statusText
                + ",\nError Thrown: " + errorThrown );
              });
      });


//on clicking the button, 'add node type'
      d3.select("#add_node_type").on("click",function(){
        var label = prompt("Please specify the name of new type, say, in 1 or 2 letters.","");
	while(current_graph.node_types.indexOf(label) != -1) label = prompt("A node type with this name already exists. Please enter a different name", "");
        if(!label) return;
        current_graph.node_types.push(label);
	current_node_type = label;
	current_node_color = color(current_graph.node_types.length - 1);
        current_graph.update_node_types_panel();
      });

//on clicking the button, 'New rule'
      d3.select("#new_rule").on("click", function(){
        var rule_name = prompt("Please specify a name for the rule.", "");
	while(rules_names.indexOf(rule_name) != -1) rule_name = prompt("A rule with this name already exists. Please enter a different name", "");
	if(!rule_name) return;
        rules_names.push(rule_name);
	current_rule_name = rule_name;
        var index = generative_grammar_rules.length;
        generative_grammar_rules.push({"name":rule_name, "nodes":[],"links":[], "node_types":[]});


	  current_graph.index.name = "Rule Graph";
	  current_graph.index[current_graph.index.name] = index;
	  initialize_graph(current_graph, generative_grammar_rules[index]);
	  //current_graph.restart();
	  update_rules_names_panel();
	  current_tab = "Rule Graph";
	  update_tabs_panel();
	  current_graph.update_node_types_panel();
      });

//on clicking the button, 'new_graph'
      d3.select("#new_graph").on("click", function(){
        var graph_name = prompt("Please specify a name for the rule.", "");
	while(graphs_names.indexOf(graph_name) != -1) graph_name = prompt("A graph with this name already exists. Please enter a different name", "");
	if(!graph_name) return;
        graphs_names.push(graph_name);
	current_graph_name = graph_name;
        var index = graphs.length;
        graphs.push({"name":graph_name, "nodes":[],"links":[], "node_types":[]});


	  current_graph.index.name = "Main Graph";
	  current_graph.index[current_graph.index.name] = index;
	  initialize_graph(current_graph, graphs[index]);
	  //current_graph.restart();
	  update_graphs_names_panel();
	  current_tab = "Main Graph";
	  update_tabs_panel();
	  current_graph.update_node_types_panel();
      });


//on clicking the button, transform graph
      d3.select('#transform_graph').on("click", function(){
        main_graph.transform_graph(current_LHS_graph, current_RHS_graph);
      });

    });

</script>


