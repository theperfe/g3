	<!DOCTYPE html>
	<meta charset="utf-8">
	<head>
	<style>
	.link {
	  stroke: steelblue;
	  stroke-width: 3;
	}
	.node{
		stroke: white;
		stroke-width: 1.5px;
	}
	.node_label{
		stroke:none;
	}

	#graph_panel{
		float:left;
		min-width:900px;
		min-height: 600px;
	}

	#selection_panel{
		float: right;
		position: relative;
		min-height: 600px;
		min-width: 300px;
		display: block;
	}

	p{
		margin:0em;
	}
	</style>
	<script type="text/javascript" src="../scripts/d3.js"></script>
<!--	<script src="http://d3js.org/d3.v3.min.js"></script>-->
	<script src="../scripts/jquery.min.js"></script>
	</head>
	<body>
		<div id="viz">
		</div>
<!--		<div id="selection_panel"></div>-->
		<div id="buttons" align="center">
			<button id="save_data"> Save the graph </button>
			<button id="start_delete_node"> Start deleting </button>
			<button id="stop_delete_node"> Stop deleting </button>
			<button id="add_node_type"> Add Node Type </button>
		</div>
		<script type="text/javascript">

	//In this I am trying to add the select boxes on the right side of the window so that people can specify the type of the node they want i.e. they will only specify the label to the node. I will choose a color randomly. Later I will add the option, like AGG, if they want to choose circle or rectangle or oval etc.

		function Graph(nodes, links){	//Graph constructor
			this.nodes = nodes;
			this.links = links;
			this.count = 0;
		}

			Graph.prototype.restart= restart;
			Graph.prototype.update= update;
			Graph.prototype.update_links= update_links;
			Graph.prototype.update_nodes= update_nodes;
			Graph.prototype.update_shapes= update_shapes;
			Graph.prototype.update_labels= update_labels;
			Graph.prototype.update_titles= update_titles;
			Graph.prototype.enter= enter;
			Graph.prototype.enter_links= enter_links;
			Graph.prototype.enter_nodes= enter_nodes;
			Graph.prototype.exit= exit;
			Graph.prototype.exit_links= exit_links;
			Graph.prototype.exit_nodes= exit_nodes;
			Graph.prototype.key= key;
			Graph.prototype.add_node= add_node;
			Graph.prototype.delete_node= delete_node;
			Graph.prototype.add_link= add_link;
			Graph.prototype.tick= tick;
			Graph.prototype.node_click= node_click;


			var main_graph;	//this is the graph in the graph panel on which grammar rules will be applied

			var width = 900;
			var height = 600;
			var color = d3.scale.category20();


			var delete_bool = false;
			var node_types = ["E"];	//to store the node types and display them in selection panel
			var current_node_type = "E";
			var current_node_color = color(1);

//svg for main graph
			var svg = d3.select("#viz")
				.append("section")
				.attr("id", "graph_panel")
				.attr("width",width)
				.attr("height", height)
				.style("border", "2px solid black")
				.append("svg");

//svg for selecting node types
			var svg2 = d3.select("#viz")
					.append("aside")
					.attr("id", "selection_panel")
					.attr("width",300)
					.attr("height",600)
					.style("border", "2px solid black");


			var node = svg.selectAll(".node");
			var link = svg.selectAll(".link");

//loading initial graph from json file. This graph can later be modified through the GUI.
			d3.json("../json/44.json", function(error, graph) {
				node_types = graph.node_types;
//				console.log(graph);
//				console.log(node_types);
				main_graph = new Graph(graph.nodes, graph.links);

				main_graph.force = d3.layout.force()
					.size([width,height])
					.charge(-60)
					.linkDistance(30);

				main_graph.force.nodes(main_graph.nodes)
				.links(main_graph.links)
				.start()	//this should never be removed
				.on("tick", tick);
					
				svg.on("click", function(){
					var graph = main_graph, self_this = this;
					add_node(graph,self_this)});

				main_graph.nodes = main_graph.force.nodes(),
				main_graph.links = main_graph.force.links();
				main_graph.restart();
				update_selection_panel();
			});



/*************************************** FUNCTIONS ****************************************
* key
* add_node
* delete_node
* add_link
* tick
* node_click
* update
* enter
* exit
* update_selection_panel
*/

//key function			
			function key(datum) {
				return datum.key;
			}

//add node
//add a node by clicking anywhere on the svg canvas. While adding the key to the node, find the max. key existing till then, and add the next no. as the key to the incoming node.
			function add_node(graph, self_this) {
				console.log(d3.event);
				d3.event.stopPropagation();
				var point = d3.mouse(self_this);
				var new_key = d3.max(graph.nodes, function(datum){return datum.key}) + 1; //find the max. key and add 1 to it
				if(!new_key) new_key = 0;
				var node_item = {key:new_key,x:point[0],y:point[1],label:current_node_type,color:current_node_color,group:Math.round(Math.random()*10)};
				graph.nodes.push(node_item);
				graph.restart();
			}

//delete node
			function delete_node(d,i){
				d3.event.stopPropagation();
				var indices_to_be_deleted = [];
				console.log("index of node to be deleted is " + i);
				for(var j=0; j<this.links.length; j++){	//creating the list of indices of links to be deleted
					if((this.links[j].source.index === i) || (this.links[j].target.index === i)){
						indices_to_be_deleted.push(j);
					}
				}
				console.log(indices_to_be_deleted);
				indices_to_be_deleted.reverse();	//reversing the indices so that the largest index comes first. This is necessary since if we delete the smallest index of links first, then all the remaining links indices will change as well.

				for(var j=0; j<indices_to_be_deleted.length; j++){
					this.links.splice(indices_to_be_deleted[j],1)	//delete one element i.e. at the index j
				}

				//then delete the node itself
				this.nodes.splice(i,1);	//delete one node i.e. at the index i.
				this.restart();

			}

//add link
//add a link by clicking on the source node and the target node
			function add_link(d,i){
				console.log("entered add link");
				d3.event.stopPropagation();
				if(this.count == 1)	{ //clicked on target 
					this.target = i;
					this.target_key = this.nodes[i].key;	//I had to do this.target_key (not just target_key) because once it leaves this loop, the target_key should still be stored, but I dont want it to be a global variable.
					if (this.source !== this.target){
						var new_key = this.source_key + "-" + this.target_key; //the link key is depending on its source key and target key
						console.log(new_key);
						this.links.push({key:new_key, "source":this.source, "target":this.target});
						this.count = 0;
						this.restart();
				}
			}
					else if (this.count == 0){	//clicked on source
						this.source = i;
						this.source_key = this.nodes[i].key;
						this.count = 1;
					}
			}


//tick
				
			function tick() {
//				console.log(this);
				link.attr("x1", function(d) { return d.source.x; })
				    .attr("y1", function(d) { return d.source.y; })
				    .attr("x2", function(d) { return d.target.x; })
				    .attr("y2", function(d) { return d.target.y; });

				node.attr("transform", function(datum){return "translate("+datum.x+","+datum.y+")"});
			}

//node click
			function node_click(d,i, self_this){
				if (delete_bool === true) self_this.delete_node(d,i);
				else self_this.add_link(d,i);
				self_this.restart();
			}

/****** update *********/
			function update(){
				this.update_links();
				this.update_nodes();
			}

//update_links
			function update_links(){
				link = link.data(this.links, this.key);
			}

//update_nodes
			function update_nodes(){
				node = node.data(this.nodes, this.key);
				this.update_shapes();
				this.update_labels();
				this.update_titles();
			}

//update_shapes
			function update_shapes(){
				var self_this = this;
				var node_shapes = svg.selectAll("g .node_shape");
				node_shapes
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", function(datum, index){
					node_click(datum, index, self_this);});
			}

//update_labels
			function update_labels(){
				var node_labels = svg.selectAll("g .node_label");
				node_labels
				.text(function(datum){return datum.label;});
			}

//update_titles
			function update_titles(){
				var node_titles = svg.selectAll("g .node_title");
				node_titles
				.text(function(d,i) {return i});
			}

				
/****** enter *********/
			function enter(){
				this.enter_links();
				this.enter_nodes();
			}

//enter_links
			function enter_links(){
				link.enter().insert("line",".node")
				.attr("class", "link");
			}

//enter_nodes
			function enter_nodes(){
				var self_this = this;
				console.log(this);
				var gnode = node.enter().append("g")
					.attr("class", "node");

				var gnode_circles = gnode.append("circle")
				.attr("class", "node_shape")
				.attr("r", function(datum){
						if(datum.label === "e") return 5;
						else return 9;
					})
//				.attr("fill", function(d){ return color(d.group);})
				.attr("fill", function(d){ return d.color})
				.on("click", function(datum, index){
					node_click(datum, index, self_this);})
				.call(self_this.force.drag);

				gnode.append("text")
				.attr("class", "node_label")
				.attr("fill", "white")
				.attr("text-anchor", "middle")
				.attr("font-family", "calibri")
				.attr("font-size", 13)
				.attr("font-weight", "bold")
				.attr("y", 3.5)
				.style("pointer-events", "none") //to allow the mouse event to be passed to the circle below it.
				.text(function(datum){return datum.label;});

				gnode.append("title")
				.attr("class", "node_title")
				.text(function(d,i) {return i});
			}
				

/****** exit *********/
			function exit(){
				this.exit_links();
				this.exit_nodes();
			}

//exit_links
			function exit_links(){
				link.exit().remove();
			}

//exit_nodes
			function exit_nodes(){
				node.exit().remove();
			}
				
/****** restart *********/
			function restart()
			{
				this.update();
				this.enter();
				this.exit();
				this.force.start();
			}

/****** update selection panel *********/
			function update_selection_panel(){
				d3.select("#selection_panel").selectAll("p")
				.data(node_types)
				.enter()
				.append("p")
				.text(function(datum,index){
					console.log(this);
					return datum;
				})
				.on("click", function(datum,index){
					current_node_type = node_types[index];
					current_node_color = color(index);
					console.log(d3.rgb(current_node_color));
				})
				.on("mouseover", function(datum,index){
					d3.select(this).style("background-color",color(index));
				})
				.on("mouseout",function(datum,index){
					d3.select(this).style("background-color","white");
				});
			}


/*************************************** HANDLING THE BUTTONS *****************************************/

			$(document).ready(function(){
				$("#save_data").click(function(){
				nodes_copy = [];	//I will copy only some attributes of nodes into this.
				links_copy = [];
				for (var i=0; i<main_graph.nodes.length; i++)
				{
					nodes_copy[i] = {};
					nodes_copy[i].key = main_graph.nodes[i].key;
					nodes_copy[i].label = main_graph.nodes[i].label;
					nodes_copy[i].name = main_graph.nodes[i].name;
					nodes_copy[i].group = main_graph.nodes[i].group;
					nodes_copy[i].color = main_graph.nodes[i].color;
				}
				
				for(var i=0; i<main_graph.links.length; i++)
				{

					links_copy[i] = {};
					links_copy[i].key = main_graph.links[i].key;
					links_copy[i].source = main_graph.links[i].source.index;
					links_copy[i].target = main_graph.links[i].target.index;
				}
			

					nodes_string = JSON.stringify(nodes_copy);					
					links_string = JSON.stringify(links_copy);
					node_types_string = JSON.stringify(node_types);
					console.log(nodes_string);
					console.log(links_string);
					console.log(node_types_string);
					
					$.ajax({
						type: "POST",
						url: "../php/44.php",
						//data: "name=John&location=Boston&count="+count
						data: {nodes:nodes_string, links: links_string, node_types:node_types_string}
						}).done( function(msg){
							alert( "Data Saved: \n" + msg );
							}).fail( function( xmlHttpRequest, statusText, errorThrown ) {
								alert(
									"Your form submission failed.\n\n"
									+ "XML Http Request: " + JSON.stringify( xmlHttpRequest )
									+ ",\nStatus Text: " + statusText
									+ ",\nError Thrown: " + errorThrown );
								});
				});

//on clicking the button, 'start deleting'
				$("#start_delete_node").click(function(){delete_bool = true;
				console.log(delete_bool);
				d3.select("body").append("text")
				.attr("class","delete_text")
				.text("Click on any node to delete it.");});

//on clicking the button, 'stop deleting'
				$("#stop_delete_node").click(function(){delete_bool = false;
				console.log(delete_bool);
				d3.select(".delete_text").remove();});
				
//on clicking the button, 'add node type'
				d3.select("#add_node_type").on("click",function(){
					var label = prompt("Please specify the name of new type, say, in 1 or 2 letters.","");
					if(!label) label="E";
					node_types.push(label);
					update_selection_panel();

				});

			});

	</script>


